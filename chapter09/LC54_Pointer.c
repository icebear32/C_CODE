//笔试题

#include <stdio.h>

int main()
{
	char arr[] = "abcdef";

	printf("%d\n", strlen(arr)); // 6 
	/*
		因为arr存放的是 abcdef\0，arr存放的是首元素地址，所以是从首元素开始计算
		strlen(arr)计算的数组的长度，遇到 '\0' 结束，计算'\0'前面的长度
		所以长度为 6  
	*/

	printf("%d\n", strlen(arr + 0)); // 6 
	/*
		因为arr存放的是 abcdef\0，（arr + 0）存放的是首元素地址，所以是从首元素开始计算
		strlen(arr)计算的数组的长度，遇到 '\0' 结束，计算'\0'前面的长度
		所以长度为 6
	*/

	//printf( "%d\n", strlen(*arr)); // err
	// *arr 是arr首元素地址，解引用得到首元素地址的'a'
	// 'a'的码值是 '97'，strlen函数直接调用'97'的地址去求长度
	// 属于非法调用，间接寻址

	//printf( "%d\n", strlen( arr[1])); // err
	// arr[1] 是arr的第二个元素，得到的是'b'
	// 'b'的码值是 '98'，strlen函数直接调用'98'的地址去求长度
	// 属于非法调用，间接寻址

	printf("%d\n", strlen(&arr)); //6 
	// &arr - 存的是数组的地址 - 应该放在数组指针 char(*p)[7] = &arr;上
	//传入strlen会有报错，但是还是可以强行转换执行，当做数组的地址执行
	//所以从首元素开始计算长度，得到 6

	printf("%d\n", strlen(&arr + 1)); //随机值
	// &arr - 存的是数组的地址 - 应该放在数组指针 char(*p)[7] = &arr;上
	//传入strlen会有报错，但是还是可以强行转换执行，当做数组的地址执行
	//所以从首元素开始计算长度，但是（&arr + 1）就跳过整个数组，无法知道后面的元素
	//所以得到的是随机值

	printf("%d\n", strlen(&arr[0] + 1)); //5
	// &arr - 存的是数组的地址 - 应该放在数组指针 char(*p)[7] = &arr;上
	//传入strlen会有报错，但是还是可以强行转换执行，当做数组的地址执行
	//所以 &arr[0] 是从首元素开始计算长度，但是（&arr[0] + 1）就跳过数组的一个元素，
	// 从第二个元素开始计算长度
	//所以得到的是 5 

	return 0;
}